mb.ratio = c(0.4,0.6)))
}
Upset_plot_no_merge(a)
a <- readRDS(file = "../Results/ebopluslist_genes_1.rds")
b <- readRDS(file = "../Results/ebopluslist_genes_2.rds")
c <- readRDS(file = "../Results/ebopluslist_genes_3.rds")
d <- readRDS(file = "../Results/ebopluslist_genes_4.rds")
View(a)
Upset_plot_no_merge(a)
Upset_plot_no_merge(b)
Upset_plot_no_merge(c)
Upset_plot_no_merge(d)
#' @description
#' This function takes as input a list containing a list of genes,
#' one for each Classifier used, and a threshold value indicating the
#' minimum number of algorithms in which the gene should be found
#' @param lista_geni list of list containing important genes for each Algorithm
#' used in previous simulations
#' @param n_min threshold number indicating the minimum number of algorithms
#' in which each gene should be contemporary important
#' @returns consensus.list <- list of genes found by consensus
getConsensus.list <- function(lista_geni = readRDS(file = "../Results/list_genes_1.rds"),
n_min = 7) {
setwd("/Users/giorgiomontesi/Desktop/Universita_di_Siena/A_PhD_Project/Biomarker_Prediction/ensembleBP/Codes")
library(tidyverse)
# Get all unique genes from all algorithms
geni_unici <- sort(unique(unlist(lista_geni)))
# Init a df
df <- data.frame(RowName = names(lista_geni))
# Add new cols for each unique gene and assign TRUE/FALSE based on its presence
for (gene in geni_unici) {
df[[gene]] <- map_lgl(df$RowName, ~ gene %in% lista_geni[[.x]])
}
# Set rownames as the Algorithm name
rownames(df) <- df$RowName
df$RowName <- NULL
df <- as.data.frame(t(df))
df <- as.data.frame(ifelse(df == "TRUE", 1, 0))
# Set consensus condition
ds <- df[rowSums(df) > (n_min - 1), ]
consensus.list <- list(consensusGenes = rownames(ds))
print(consensus.list)
return(consensus.list)
# Aggiungi questa riga alla fine della funzione getConsensus.list per restituire l'output in formato JSON
cat(jsonlite::toJSON(consensus.list))
#return(jsonlite::toJSON(consensus.list))
}
# # Example usage function:
consensus.geneList <- getConsensus.list(lista_geni =
readRDS(file = "../Results/ebopluslist_genes_1.rds"),
n_min = 4)
consensus.geneList <- getConsensus.list()
# # Example usage function:
consensus.geneList <- getConsensus.list(lista_geni =
readRDS(file = "../Results/ebopluslist_genes_1.rds"),
n_min = 4)
View(consensus.geneList)
gene_list <- consensus.geneList
library(clusterProfiler)
library(org.Hs.eg.db)
library(stringr)
library(tidyverse)
library(circlize)
library(reshape2)
library(RColorBrewer)
library(ggplot2)
#' @description
#' function to perform Reactome enrichment
#' @param gene_list list of genes in SYMBOL format on which to perform enrichment analysis
#' @param keyType Organism default "hgnc" referring to HomoSapiens
#' @param pval pvalue cutoff default 0.05
#' @param signif Logical TRUE: returns only significant enrichment results,
#'                      FALSE: returns all enrichment results
#' @returns DataFrame contsining enrichment results (all or only significant depending on signif)
enrich.React <- function(gene_list, keyType = "hgnc", pval = 0.05, signif = TRUE){
reactome_results <- enrichPC(gene = gene_list,
source = "reactome",
keyType = keyType,
pvalueCutoff = pval)
if (signif == TRUE){
padj <- pval
return(reactome_results@result[reactome_results@result$p.adjust < padj,])
} else {
return(reactome_results@result)
}
}
reactome_results_signif <- enrich.React(gene_list = gene_list)
View(consensus.geneList)
#' @param gene_list list of genes in on which to perform enrichment analysis
#' @param keyType format of gene_list, default "SYMBOL"
#' @param pval pvalue cutoff default 0.05
#' @param ont GO ontology on which to perform enrichment c("BP","MF","")
#' @param groupGO Logical TRUE: groups similar GO pathways together,
#'                       FALSE: returns all enriched GO pathways
#' @param signif Logical  TRUE: returns only significant enrichment results,
#'                       FALSE: returns all enrichment results
#' @param level level to group GO terms
#' @returns DataFrame containing enrichment results (all or only significant depending on signif)
enrich.GO <- function(gene_list, keyType = "SYMBOL", pval = 0.05,
ont = "BP", groupGO = TRUE, signif = TRUE, level = 4){
go_results <- enrichGO(gene = gene_list,
OrgDb = org.Hs.eg.db,
keyType = keyType,
ont = ont,
pvalueCutoff = pval,
pool = 1)
if (groupGO == TRUE & signif == TRUE){
padj <- pval
group_go <- groupGO(gene_list, OrgDb='org.Hs.eg.db',
keyType = keyType, ont = ont,
level = level)
go_level <- group_go@result$ID
go_signif <- go_results@result[go_results@result$p.adjust < padj, ]
go_signif <- go_signif[go_signif$ID %in% go_level, ]
return(go_signif)
} else if (groupGO == TRUE & signif == FALSE){
padj <- pval
group_go <- groupGO(gene_list, OrgDb='org.Hs.eg.db',
keyType = keyType, ont = ont,
level = level)
go_level <- group_go@result$ID
go_signif <- go_results@result
go_signif <- go_signif[go_signif$ID %in% go_level, ]
return(go_signif)
} else if (groupGO == FALSE & signif == TRUE){
padj <- pval
go_signif <- go_results@result[go_results@result$p.adjust < padj, ]
return(go_signif)
} else{
return(go_results@result)
}
}
go_grouped_signif <- enrich.GO(gene_list = gene_list, pval = 0.01)
go_grouped_signif <- enrich.GO(gene_list = gene_list, pval = 0.01, keyType = "ENTREZID")
View(gene_list)
keyType = "ENTREZID"
pval = 0.05
ont = "BP"
groupGO = TRUE
signif = TRUE
level = 4
go_results <- enrichGO(gene = gene_list,
OrgDb = org.Hs.eg.db,
keyType = keyType,
ont = ont,
pvalueCutoff = pval,
pool = 1)
reactome_results <- enrichPC(gene = gene_list,
source = "reactome",
keyType = keyType,
pvalueCutoff = pval)
#' @description
#' function to perform Reactome enrichment
#' @param gene_list list of genes in SYMBOL format on which to perform enrichment analysis
#' @param keyType Organism default "hgnc" referring to HomoSapiens
#' @param pval pvalue cutoff default 0.05
#' @param signif Logical TRUE: returns only significant enrichment results,
#'                      FALSE: returns all enrichment results
#' @returns DataFrame contsining enrichment results (all or only significant depending on signif)
enrich.React <- function(gene_list, keyType = "uniprot", pval = 0.05, signif = TRUE){
reactome_results <- enrichPC(gene = gene_list,
source = "reactome",
keyType = keyType,
pvalueCutoff = pval)
if (signif == TRUE){
padj <- pval
return(reactome_results@result[reactome_results@result$p.adjust < padj,])
} else {
return(reactome_results@result)
}
}
keyType = "uniprot"
reactome_results <- enrichPC(gene = gene_list,
source = "reactome",
keyType = keyType,
pvalueCutoff = pval)
View(gene_list)
gene_list[["consensusGenes"]]
ds <- read.csv2("../Data/Eboplus/gene_symbol_conversion.csv")
View(ds)
for (i in gene_list$consensusGenes){
print(gene_list$consensusGenes[i])
}
i =1
gene_list$consensusGenes[[i]]
for (i in gene_list$consensusGenes){
print(gene_list$consensusGenes[[i]])
}
gene_list$consensusGenes
len(gene_list$consensusGenes)
length(gene_list$consensusGenes)
1:length(gene_list$consensusGenes)
for (i in 1:length(gene_list$consensusGenes)){
print(gene_list$consensusGenes[[i]])
}
gino <- gene_list
View(gino)
ds[ds$ensembl == gene_list$consensusGenes[[i]], "symbol"]
i=1
ds[ds$ensembl == gene_list$consensusGenes[[i]], "symbol"]
for (i in 1:length(gene_list$consensusGenes)){
print(gene_list$consensusGenes[[i]])
#gene_list$consensusGenes[[i]] <-
print(ds[ds$ensembl == gene_list$consensusGenes[[i]], "symbol"])
}
View(ds)
ds$ensembl == gene_list$consensusGenes[[i]]
ds[ds$ensembl == gene_list$consensusGenes, "symbol"]
for (i in 1:length(gene_list$consensusGenes)){
print(gene_list$consensusGenes[[i]])
gino$consensusGenes[[i]] <- (ds[ds$ensembl == gene_list$consensusGenes[[i]], "symbol"])
}
i = 1
ds[ds$ensembl == gene_list$consensusGenes[[i]], "symbol"]
!is.na(ds[ds$ensembl == gene_list$consensusGenes[[i]], "symbol"])
View(ds)
ds$symbol[ds$ensembl== gene_list$consensusGenes[[i]]]
View(gene_list)
gene_list[["consensusGenes"]]
View(ds)
for (i in c(1:length(gene_list$consensusGenes))){
print(gene_list$consensusGenes[[i]])
#gino$consensusGenes[[i]] <-
#(ds[ds$ensembl == gene_list$consensusGenes[[i]], "symbol"])
ds$symbol[ds$ensembl== gene_list$consensusGenes[[i]]]
}
for (i in c(1:length(gene_list$consensusGenes))){
print(gene_list$consensusGenes[[i]])
#gino$consensusGenes[[i]] <-
#(ds[ds$ensembl == gene_list$consensusGenes[[i]], "symbol"])
print(ds$symbol[ds$ensembl== gene_list$consensusGenes[[i]]])
}
m <- match(gino$consensusGenes, ds$ensembl)
gino$consensusGenes <- ds$symbol[m]
View(gino)
gene_list <- gino
View(gene_list)
reactome_results <- enrichPC(gene = gene_list,
source = "reactome",
keyType = keyType,
pvalueCutoff = pval)
#' @description
#' function to perform Reactome enrichment
#' @param gene_list list of genes in SYMBOL format on which to perform enrichment analysis
#' @param keyType Organism default "hgnc" referring to HomoSapiens
#' @param pval pvalue cutoff default 0.05
#' @param signif Logical TRUE: returns only significant enrichment results,
#'                      FALSE: returns all enrichment results
#' @returns DataFrame contsining enrichment results (all or only significant depending on signif)
enrich.React <- function(gene_list, keyType = "hgnc", pval = 0.05, signif = TRUE){
reactome_results <- enrichPC(gene = gene_list,
source = "reactome",
keyType = keyType,
pvalueCutoff = pval)
if (signif == TRUE){
padj <- pval
return(reactome_results@result[reactome_results@result$p.adjust < padj,])
} else {
return(reactome_results@result)
}
}
reactome_results_signif <- enrich.React(gene_list = gene_list)
reactome_results <- enrichPC(gene = gene_list,
source = "reactome",
keyType = keyType,
pvalueCutoff = pval)
gene_list <- gino[[1]]
#' @description
#' function to perform Reactome enrichment
#' @param gene_list list of genes in SYMBOL format on which to perform enrichment analysis
#' @param keyType Organism default "hgnc" referring to HomoSapiens
#' @param pval pvalue cutoff default 0.05
#' @param signif Logical TRUE: returns only significant enrichment results,
#'                      FALSE: returns all enrichment results
#' @returns DataFrame contsining enrichment results (all or only significant depending on signif)
enrich.React <- function(gene_list, keyType = "hgnc", pval = 0.05, signif = TRUE){
reactome_results <- enrichPC(gene = gene_list,
source = "reactome",
keyType = keyType,
pvalueCutoff = pval)
if (signif == TRUE){
padj <- pval
return(reactome_results@result[reactome_results@result$p.adjust < padj,])
} else {
return(reactome_results@result)
}
}
reactome_results_signif <- enrich.React(gene_list = gene_list)
View(reactome_results_signif)
reactome_results <- enrich.React(gene_list = gene_list, signif = F)
View(reactome_results)
#' @param gene_list list of genes in on which to perform enrichment analysis
#' @param keyType format of gene_list, default "SYMBOL"
#' @param pval pvalue cutoff default 0.05
#' @param ont GO ontology on which to perform enrichment c("BP","MF","")
#' @param groupGO Logical TRUE: groups similar GO pathways together,
#'                       FALSE: returns all enriched GO pathways
#' @param signif Logical  TRUE: returns only significant enrichment results,
#'                       FALSE: returns all enrichment results
#' @param level level to group GO terms
#' @returns DataFrame containing enrichment results (all or only significant depending on signif)
enrich.GO <- function(gene_list, keyType = "SYMBOL", pval = 0.05,
ont = "BP", groupGO = TRUE, signif = TRUE, level = 4){
go_results <- enrichGO(gene = gene_list,
OrgDb = org.Hs.eg.db,
keyType = keyType,
ont = ont,
pvalueCutoff = pval,
pool = 1)
if (groupGO == TRUE & signif == TRUE){
padj <- pval
group_go <- groupGO(gene_list, OrgDb='org.Hs.eg.db',
keyType = keyType, ont = ont,
level = level)
go_level <- group_go@result$ID
go_signif <- go_results@result[go_results@result$p.adjust < padj, ]
go_signif <- go_signif[go_signif$ID %in% go_level, ]
return(go_signif)
} else if (groupGO == TRUE & signif == FALSE){
padj <- pval
group_go <- groupGO(gene_list, OrgDb='org.Hs.eg.db',
keyType = keyType, ont = ont,
level = level)
go_level <- group_go@result$ID
go_signif <- go_results@result
go_signif <- go_signif[go_signif$ID %in% go_level, ]
return(go_signif)
} else if (groupGO == FALSE & signif == TRUE){
padj <- pval
go_signif <- go_results@result[go_results@result$p.adjust < padj, ]
return(go_signif)
} else{
return(go_results@result)
}
}
go_grouped_signif <- enrich.GO(gene_list = gene_list, pval = 0.01, keyType = "SYMBOL")
View(go_grouped_signif)
go_signif <- enrich.GO(gene_list = gene_list, pval = 0.01, signif = T, groupGO = F)
View(go_signif)
#' @param transparency intensity of the color related to the chordDiagram, default =0.5
#' @param facing determines the orientation of the text relative to the circle circos.trackPlotRegion
#'               function,default ="clockwise"
#' @param cex determines the sixe of the text relative to the circle circos.trackPlotRegion function
#'            default = 0.7
#' @param legend Logical TRUE: shows the legend
#'                       FALSE: doesn't show the legend
#' @param legend_title assigns the title for the legend
#' @returns a circos plot displaying, for each significantly enriched modules,the genes
#'          from the list that are involved.
circos.plot <- function(enrichment_results,
palette_genes = "Set2", palette_modules = "Paired",
transparency = 0.5, facing = "clockwise",
cex = 0.7, legend = TRUE, legend_title ="circos_plot_legend"){
geni_sel <- unique(unlist(str_split(enrichment_results$geneID, "/")))
big_dat <- matrix(nrow = length(geni_sel), ncol = nrow(enrichment_results))
rownames(big_dat) <- geni_sel
colnames(big_dat) <- c(enrichment_results$ID)
for (i in 1:ncol(big_dat)){
big_dat[,i] <- as.numeric(rownames(big_dat) %in%
unlist(str_split(enrichment_results$geneID[i], "/")))
}
big_dat <- as.data.frame(big_dat)
df <- big_dat
df$ID <- rownames(df)
df <- melt(df, by = df$ID)
colori_geni <- colorRampPalette(brewer.pal(brewer.pal.info[palette_genes, 1],
name = palette_genes))(length(unique(df$ID)))
colori_moduli <- colorRampPalette(brewer.pal(brewer.pal.info[palette_modules, 1],
name = palette_modules))(length(unique(df$variable)))
circos_enriched = function(){
if (legend == T) {
par(mar = c(0,0,0,15))
} else {
par(mar = c(0,0,0,0))
}
chordDiagram(df,
transparency = 0.5,
annotationTrack = c("grid", "axis"),
preAllocateTracks = 1,
big.gap = 10,
grid.col = c(colori_geni, colori_moduli),
col = c(colori_geni, colori_moduli))
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
sector.name = get.cell.meta.data("sector.index")
circos.text(mean(xlim),
ylim[1] + .1,
sector.name,
facing = "clockwise",
niceFacing = TRUE,
adj = c(0, 0.5),
cex = 0.7)
circos.axis(h = "top",
labels.cex = 0.2,
sector.index = sector.name,
track.index = 2)
}, bg.border = NA)
#
if (legend == T){
# Aggiungi la legenda
legend_df <- enrichment_results[, c("ID", "Description")]
# Imposta le coordinate per la legenda
par(xpd=TRUE)
lgd.x <- par("usr")[2]*0.9
lgd.y <- par("usr")[3]*0.1
legend(x = lgd.x, y = lgd.y,
title = legend_title,
title.cex = 0.7,
legend = str_trunc(legend_df$Description, 40),
fill = colori_moduli,
col = "black", cex = 0.6, bty = "n", inset=c(0, 0.1))
}
}
circos_enriched()
}
circos.plot(enrichment_results = reactome_results_signif,
legend = T,
palette_genes = "Set1",palette_modules = "GnBu")
go_grouped_signif <- enrich.GO(gene_list = gene_list, pval = 0.05, keyType = "SYMBOL")
View(go_grouped_signif)
go_grouped <- enrich.GO(gene_list = gene_list, pval = 0.05, signif = F)
go_results <- enrich.GO(gene_list = gene_list, pval = 0.05, signif = F, groupGO = F)
go_signif <- enrich.GO(gene_list = gene_list, pval = 0.05, signif = T, groupGO = F)
View(go_signif)
circos.plot(enrichment_results = go_signif,
legend = T,
palette_genes = "Set1",palette_modules = "GnBu")
#'
#'
#'
#'
#'
#'
#'
bar.plot <- function(enrichment_results, pcutoff = 0.05, low.col = "indianred",
high.col = "lightblue"){
library(viridis)
enrichment_results <- enrichment_results[order(enrichment_results$p.adjust), ]
ggplot(data = enrichment_results, aes(x = p.adjust, y = reorder(Description, -p.adjust), fill = p.adjust)) +
geom_bar(stat = "identity") +
#scale_fill_viridis(option = viridis.pal) +
scale_fill_gradient(low = low.col, high = high.col) +
geom_vline(xintercept = pcutoff, linetype="dashed",
color = "indianred") +
theme_minimal()
}
bar.plot(enrichment_results = reactome_results[reactome_results$p.adjust< 0.5, ])
# # Example usage function:
consensus.geneList <- getConsensus.list(lista_geni =
readRDS(file = "../Results/ebopluslist_genes_1.rds"),
n_min = 3)
View(consensus.geneList)
gene_list <- consensus.geneList
ds <- read.csv2("../Data/Eboplus/gene_symbol_conversion.csv")
gino <- gene_list
m <- match(gino$consensusGenes, ds$ensembl)
gino$consensusGenes <- ds$symbol[m]
gene_list <- gino[[1]]
reactome_results_signif <- enrich.React(gene_list = gene_list)
View(reactome_results_signif)
#' @param gene_list list of genes in on which to perform enrichment analysis
#' @param keyType format of gene_list, default "SYMBOL"
#' @param pval pvalue cutoff default 0.05
#' @param ont GO ontology on which to perform enrichment c("BP","MF","")
#' @param groupGO Logical TRUE: groups similar GO pathways together,
#'                       FALSE: returns all enriched GO pathways
#' @param signif Logical  TRUE: returns only significant enrichment results,
#'                       FALSE: returns all enrichment results
#' @param level level to group GO terms
#' @returns DataFrame containing enrichment results (all or only significant depending on signif)
enrich.GO <- function(gene_list, keyType = "SYMBOL", pval = 0.05,
ont = "BP", groupGO = TRUE, signif = TRUE, level = 4){
go_results <- enrichGO(gene = gene_list,
OrgDb = org.Hs.eg.db,
keyType = keyType,
ont = ont,
pvalueCutoff = pval,
pool = 1)
if (groupGO == TRUE & signif == TRUE){
padj <- pval
group_go <- groupGO(gene_list, OrgDb='org.Hs.eg.db',
keyType = keyType, ont = ont,
level = level)
go_level <- group_go@result$ID
go_signif <- go_results@result[go_results@result$p.adjust < padj, ]
go_signif <- go_signif[go_signif$ID %in% go_level, ]
return(go_signif)
} else if (groupGO == TRUE & signif == FALSE){
padj <- pval
group_go <- groupGO(gene_list, OrgDb='org.Hs.eg.db',
keyType = keyType, ont = ont,
level = level)
go_level <- group_go@result$ID
go_signif <- go_results@result
go_signif <- go_signif[go_signif$ID %in% go_level, ]
return(go_signif)
} else if (groupGO == FALSE & signif == TRUE){
padj <- pval
go_signif <- go_results@result[go_results@result$p.adjust < padj, ]
return(go_signif)
} else{
return(go_results@result)
}
}
go_grouped_signif <- enrich.GO(gene_list = gene_list, pval = 0.05, keyType = "SYMBOL")
circos.plot(enrichment_results = reactome_results_signif,
legend = T,
palette_genes = "Set1",palette_modules = "GnBu")
circos.plot(enrichment_results = go_grouped_signif,
legend = T,
palette_genes = "Set1",palette_modules = "GnBu")
